% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Scenario-Based Planning for Partially Dynamic Vehicle Routing with Stochastic Customers},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Scenario-Based Planning for Partially Dynamic Vehicle Routing
with Stochastic Customers}
\author{Lorenzo Sciandra}
\date{giugno 2022}

\begin{document}
\maketitle

\emph{Authors: Russel W. Bent, Pascal Van Hentenryck}\\
\emph{Year: 2004}

\hypertarget{introduzione}{%
\section{Introduzione}\label{introduzione}}

Il problema di routing multiveicolo con finestre temporali
({\(\mathbf{VRPTW}\)}) è un problema difficile di ottimizzazione
combinatoria che è stato studiato a fondo nel corso del tempo e che
quindi è ben risolto da procedure di ricerca locale che trovano
soluzioni molto vicine all'ottimo in tempo ragionevole. Le sue versioni
\textbf{stocastiche} e \textbf{dinamiche} sono motivate dall'intrinseca
incertezza che caratterizza molti problemi reali come la possibilità di
aggiornare i piani anche quando i veicoli sono già partiti grazie ai
computer a bordo. Le due versioni, prese separatemente, riguardano:

\begin{itemize}
\tightlist
\item
  \textbf{stocastica}: il goal è trovare un piano a priori che minimizzi
  la funzione obiettivo attesa del problema {\(\mathbf{VRPTW}\)} in cui
  qualche dato è stocastico. Si prevede generalmente la definizione di
  una \emph{funzione di ricorso} che permetta di correggere i piani nel
  caso in cui i vincoli fossero violati;
\item
  \textbf{dinamica}: in questa versione le richieste non sono
  completamente conosciute in anticipo e diventano disponibili sono nel
  corso del tempo. Generalmente si pianifica solo su quelle note fino a
  quando non capita un evento come una nuova richiesta. A quel punto il
  piano viene adattato per trattare anche quest'ultima se possibile.
\end{itemize}

Il paper propone una risoluzione a scenario multiplo
({\(\mathbf{MSA}\)}) per un problema di routing parzialmente dinamico
con finestre temporali, dove alcuni clienti sono noti all'inizio e altri
sono dinamici. L'obiettivo è riuscire a servire quante più richieste
possibili dato un certo numero di veicoli a disposizione. L'informazione
stocastica riguarda i clienti dinamici e l'uso di distribuzioni di
probabilità per prevedere le future richieste grazie ai dati passati. I
problemi \textbf{parzialmenti dinamici} possono variare molto in
complessità in base al rapporto
{\(\texttt{\#dynamic\_customers/\#total\_customers}\)}. L'idea principale di
un {\(\mathbf{MSA}\)} è di generare e risolvere continuamente scenari
che includono richieste sia statiche che dinamiche. Le decisioni prese
durante l'esecuzione sono basate su un \textbf{piano prescelto} che
evolve nel tempo. Il piano prescelto viene selezionato da una
\textbf{funzione di consenso} che sceglie il piano più simile al pool
corrente di instradamenti, implementando un' euristica di tipo
\emph{least-commitment}.

\hypertarget{formulazione-del-problema}{%
\section{Formulazione del Problema}\label{formulazione-del-problema}}

Analizziamo separatamente tutte le componenti che caratterizzzano il
problema:

\begin{itemize}
\tightlist
\item
  \textbf{CLIENTI}: ci sono {\(N\)} regioni dei clienti, chiamate
  \textbf{regioni} e {\(N^{\prime}\)} richieste di servizio dei clienti
  dalle ragioni, chiamate \textbf{clienti}. I clienti vengono numerati
  in ordine cronologico delle loro richieste. I \textbf{siti} del
  problema sono {\(\{ 0,1,...,N^{\prime}\}\)} dove {\(0\)} rappresenta
  il \textbf{deposito}. Il \textbf{costo di viaggio} tra i siti {\(i\)}
  e {\(j\)} è rappresentato da {\(c_{ij}\)} che soddisfa la
  disuguaglianza triangolare:
  {\(\forall\ i,j,k\ \ c_{ik} \leq c_{ij} + c_{jk}\)}. Ogni cliente ha
  una \textbf{domanda} {\(q_{i} \geq 0\)} e un \textbf{tempo di
  servizio} {\(s_{i} \geq 0\)};
\item
  \textbf{VEICOLI}: ci sono {\(m\)} veicoli identici che hanno
  \textbf{capacità massima} {\(Q\)};
\item
  \textbf{PERCORSI}: il percorso di un veicolo {\(r\)}, o
  \textbf{percorso}, inizia dal deposito, serve un certo numero di
  clienti e ritorna al deposito. Formalmente una route è una sequenza
  {\(\lbrack 0,v_{1},...,v_{n},0\rbrack\)} dove
  {\(1 \leq v_{i} \leq N^{\prime}\)} e sono tutti distinti. La
  \textbf{domanda di un percorso} è
  {\(q(r) = \sum\limits_{i = 1}^{n}q_{i}\)} mentre il \textbf{costo del
  percorso} è
  {\(c(r) = c_{0,v_{1}} + c_{v_{1},v_{2}} + \cdot \cdot \cdot + c_{v_{n},0}\)}.
  Con {\(\texttt{cust(r)}\)} si denotano invece i clienti del percorso {\(r\)};
\item
  \textbf{PIANO DI INSTRADAMENTO}: un piano di instradamento
  {\(\sigma\)}, o \textbf{piano}, è un insieme di percorsi
  {\(\{ r_{1},...,r_{m}\}\)} uno per ogni veicolo che serve ogni cliente
  esattamente una volta. Il piano assegna ad ogni cliente un solo
  \textbf{predecessore} {\(\texttt{pred(i},\sigma\texttt{)}\)} ed un
  solo \textbf{successore} {\(\texttt{succ(i,}\sigma\texttt{)}\)}. Il
  \textbf{costo di viaggio} di un piano {\(\sigma\)} è
  {\(c(\sigma) = \sum\limits_{r = 1}^{m}c(r)\)}. Con
  {\(\texttt{cust(}\sigma\texttt{)}\)} si identificano tutti i clienti
  serviti da un piano;
\item
  \textbf{FINESTRE TEMPORALI}: ogni sito {\(i\)} ha una finestra
  specificata da un intervallo {\(\lbrack e_{i},l_{i}\rbrack\)} che
  rappresentano rispettivamente il primo e l'ultimo possibile tempo di
  arrivo per servire il cliente {\(i\)}. Se un veicolo arriva prima di
  {\(e_{i}\)} deve aspettare fino ad {\(e_{i}\)} per iniziare il
  servizio. Nota che per il deposito {\(e_{0}\)} indica il primo istante
  in cui i veicoli possono lasciare il deposito, mentre {\(l_{0}\)}
  indica il tempo massimo in cui tutti i veicoli devono essere ritornati
  al deposito, finito il loro percorso. Un piano specifica, implicitamente, il primo tempo possibile di servizio {\(a_{i}\)} per
  ogni cliente {\(i\)} come somma del tempo per arrivare ai clienti che
  lo precedono nel percorso più il tempo minimo di servizio stimato, a
  partire da {\(e_{0}\)}. Allo stesso modo si può definire il minimo
  tempo di ritorno di un veicolo al deposito {\(a(r)\)} che segue la
  route {\(r\)}.
\end{itemize}

Una soluzione offline al problema è un piano {\(\sigma\)} che soddisfa
tutti i vincoli di capacità e di finestra temporale:

\begin{equation*}
    \begin{cases}
{q(r_{j}) \leq Q\quad} & {1 \leq j \leq m} \\
{a(r_{j}) \leq l_{0}} & {1 \leq j \leq m} \\
{a_{i} \leq l_{i}} & {\forall i \in \texttt{cust(}\sigma\texttt{)}} \\
\end{cases}
\end{equation*} 

che ha come funzione obiettivo la massimizzazione del numero di clienti:
{\(|\texttt{cust(}\sigma\texttt{)}|\)}. Nella versione dinamica non
tutti i clienti sono noti in anticipo, ma diventano disponibili solo
durante il corso del giorno.

\hypertarget{algoritmo-greedy}{%
\section{Algoritmo Greedy}\label{algoritmo-greedy}}

L'algoritmo greedy era l'approccio tradizionale per la risoluzione di
problemi di routing dinamico. Si inizia solitamente con un piano
ottenuto da un algoritmo di ricerca locale che cerca di soddisfare il
maggior numero di richieste iniziali e che gestisce le nuove richieste
non appena diventano disponibili. Per gestire quest'ultime
l'algoritmo greedy determina se c'è un punto ammissibile all'interno del
piano nel quale è possibile inserire il nuovo cliente. Se non c'è la
richiesta viene rifiutata, altrimenti viene inserito in modo da
minimizzare il costo di viaggio del piano complessivo. In generale \textbf{un
piano non specifica una singola data di partenza da ogni cliente}, ma
esattamente come per i vincoli rilascia un range ammissibile, questo
perchè nel setting dinamico è importante ritardare più che si può
decisioni, senza ovviamente compromettere il servizio. La strategia
tradizionale è quindi quella di partire da un cliente per arrivare al
successivo il prima possibile, ma non prima di {\(e_{i}\)}. In altre
parole un veicolo non aspetta mai del tempo per iniziare il servizio, ma
può aspettare prima di ripartire per servire il cliente successivo. Con
questo tipo di algoritmo non è pensato di fare la riottimizzazione del
piano una volta che un cliente viene inserito perchè porta
sperimentalmente a peggiori soluzioni. La ragione intuitiva è che le
soluzioni ottimizzate prevedono schedules stretti, orari stringenti, che
risultano molto poco flessibili al presentarsi di nuove richieste
dinamiche.

\hypertarget{multiple-plan-approach}{%
\section{Multiple Plan Approach}\label{multiple-plan-approach}}

{\(\mathbf{MPA}\)} è una generalizzazione dell'approccio
greedy la cui idea fondamentale è mantenere un insieme di piani ad ogni
passo d'esecuzione. Più precisamente {\(\mathbf{MPA}\)} genera
continuamente piani consistenti con le decisioni correnti e scarta
quelli che risultano incompatibili. Vi è poi la necessità di selezionare
un \textbf{piano prescelto} del quale verranno eseguite le azioni per
garantire il servizio delle richieste accettate. Tale piano ovviamente
evolve nel tempo e tutti gli altri mantenuti devono essere consistenti
con esso. L'approccio {\(\mathbf{MPA}\)} gestisce 4 tipi di eventi:

\begin{enumerate}
\tightlist
\item
  \textbf{Richiesta di servizio}: aggiorna l'insieme dei piani per
  accogliere la nuova richiesta;
\item
  \textbf{Partenza dei veicoli}: possono invalidare qualche piano non
  coerente con l'evento;
\item
  \textbf{Generazione del piano}: può aggiornare il piano prescelto;
\item
  \textbf{Timeouts}: qualche piano potrebbe risultare non valido nel
  corso del tempo. Questo accade quando un piano specifica che un
  veicolo deve partire perchè è stato raggiunto il suo tempo massimo
  presso un cliente, mentre il piano prescelto prevede che debba ancora
  aspettare.
\end{enumerate}

\hypertarget{gestione-degli-eventi}{%
\subsection{Gestione degli eventi}\label{gestione-degli-eventi}}

Ad ogni istante temporale {\(t\)}, {\(\mathbf{MPA}\)} mantiene un set di
piani {\(S_{t}\)} e un piano prescelto {\(\sigma_{t}^{\ast}\)}. Per ogni
evento bisogna specificare come ottenere {\(S_{t + 1}\)} e
{\(\sigma_{t + 1}^{\ast}\)} a partire dalla coppia dell'istante
precedente. Gli eventi verranno trattati singolarmente, nel caso in cui
ne capitassero di più tipi contemporaneamente dovranno essere ordinati e
gestiti col seguente ordinamento: \emph{timeouts, generazione del piano,
richiesta di servizio, partenza del veicoli}. Si farà uso di un insieme
di funzioni {\(f_{t}\)} per rankare i piani e selezionare il prescelto.

\hypertarget{timeout}{%
\subsubsection{Timeout}\label{timeout}}

Al tempo {\(t\)} un piano {\(\sigma\)} può diventare invalido quando un
veicolo {\(v\)} sta aspettando ad un sito {\(i\)} e il piano
{\(\sigma\)} specifica che {\(t\)} è il tempo massimo di partenza da
{\(i\)}:

\begin{equation*}
    \begin{split}
        S_{t + 1} & {= \{\sigma \in S_{t}\ |\ \texttt{feasible(}\sigma,\texttt{t)}\}} \\
\sigma_{t + 1}^{\ast} & {= \sigma_{t}^{\ast}} \\
    \end{split}
\end{equation*}


Dove abbiamo che:

\[\texttt{feasible(}\sigma,\texttt{t)} = true\;\Longleftrightarrow\;\forall i \in \texttt{depart(t):\ ldt(}\sigma,\texttt{i)} \leq t\]

in cui {\(\texttt{ldt(}\sigma,\texttt{i)}\)} specifica il tempo massimo
di partenza da un cliente {\(i\)} nel piano {\(\sigma\)} e
{\(\texttt{depart(t)}\)} è l'insieme dei clienti dai quali un veicolo è
partito prima o al massimo al tempo {\(t\)}.

\hypertarget{generazione-di-un-piano}{%
\subsubsection{Generazione di un piano}\label{generazione-di-un-piano}}

Quando al tempo {\(t\)} un nuovo piano {\(\sigma\)} viene generato,
allora questo viene aggiunto all'insieme {\(S_{t}\)} e il nuovo piano
prescelto viene ricalcolato. I piani hanno la garanzia di essere
compatibili con il corrente piano prescelto perchè includono tutte le
decisioni esistenti che sono state fatte fino al tempo {\(t\)}.

\begin{equation*}
    \begin{split}
        S_{t + 1} & {= S_{t}\  \cup \ \{\sigma\}} \\
\sigma_{t + 1}^{\ast} & {= \arg\max\limits_{\sigma \in S_{t + 1}}\ f_{t}(\sigma)} \\
    \end{split}
\end{equation*}

\hypertarget{richiesta-di-servizio}{%
\subsubsection{Richiesta di servizio}\label{richiesta-di-servizio}}

Per una richiesta di un cliente {\(i\)} al tempo {\(t\)},
{\(\mathbf{MPA}\)} deve determinare quale piano in {\(S_{t}\)} è in
grado di gestirlo. Se nessuno può gestire la richiesta questa viene rifiutata
altrimenti si aggiorna {\(S_{t}\)} in modo che contenga solamente i
piani che sappiano gestirla con minimo costo di viaggio:

\begin{equation*}
    \begin{split}
         & {F = \{\texttt{insert(}\sigma,\texttt{i)}\ |\ \sigma \in S_{t}\  \land \ \texttt{feasibleInsert(}\sigma,\texttt{i)}\}} \\
 & \\
 & {if\ \ F \neq \varnothing\ \ then} \\
 & {\qquad S_{t + 1} = F} \\
 & {\qquad\sigma_{t + 1}^{\ast} = \arg\max\limits_{\sigma \in S_{t + 1}}\ f_{t}(\sigma)} \\
 & {else} \\
 & {\qquad S_{t + 1} = S_{t}} \\
 & {\qquad\sigma_{t + 1}^{\ast} = \sigma_{t}^{\ast}} \\
    \end{split}
\end{equation*}


dove {\(\texttt{feasibleInsert(}\sigma,\texttt{i)}\)} restituisce
\textbf{true} se e solo se esiste un punto di inserzione per il cliente
{\(i\)} nel piano {\(\sigma\)} ed
{\(\texttt{insert(}\sigma,\texttt{i)}\)} restituisce un piano
{\(\sigma^{\prime}\)} ottenuto da {\(\sigma\)} inserendo la richiesta
del cliente {\(i\)} in modo da minimizzare il costo complessivo del
viaggio, ovviamente sempre soddisfacendo i vincoli.

\hypertarget{partenza-dei-veicoli}{%
\subsubsection{Partenza dei veicoli}\label{partenza-dei-veicoli}}

Quando il piano prescelto {\(\sigma_{t}^{\ast}\)} specifica che il
veicolo {\(v\)} deve partire dal cliente {\(i\)} al tempo {\(t\)} è
necessario rimuovere da {\(S_{t}\)} tutti i piani che sono
incompatibili:

\begin{equation*}
    \begin{split}
        S_{t + 1} & {= \{\sigma \in S_{t}\ |\ \texttt{compatible(}\sigma,\sigma_{t}^{\ast},\texttt{t)}\}} \\
\sigma_{t + 1}^{\ast} & {= \arg\max\limits_{\sigma \in S_{t + 1}}\ f_{t}(\sigma)} \\
    \end{split}
\end{equation*}

dove {\(\texttt{compatible(}\sigma,\sigma_{t}^{\ast},\texttt{t)}\)}
restituisce \textbf{true} se il piano {\(\sigma\)} è compatibile con il
prescelto {\(\sigma_{t}^{\ast}\)} fino al tempo {\(t\)}. Formalmente
abbiamo che:

\[\texttt{compatible(}\sigma,\sigma_{t}^{\ast},\texttt{t)} = true\;\Longleftrightarrow\;\forall i \in \texttt{depart(t)}:\texttt{succ(}\sigma_{t}^{\ast},\texttt{i)\ =\ succ(}\sigma,\texttt{i)}\]

\hypertarget{funzione-consenso}{%
\subsection{Funzione Consenso}\label{funzione-consenso}}

{\(\mathbf{MPA}\)} è parametrizzato da funzioni di rank {\(f_{t}\)} che
selezionano ad ogni istante {\(t\)} il piano prescelto, se necessario.
L'idea è usare una \textbf{funzione consenso} che selezioni il piano che
sia il più simile possibile a tutti gli altri piani in {\(S_{t}\)}. Dato che
questo piano non si discosterà molto da tutti gli altri piani in
{\(S_{t}\)} la funzione consenso può essere vista come una strategia di
\emph{least commitment}, euristica ben nota in AI. Più precisamente
possiamo dire che ad ogni istante {\(t\)} l'algoritmo mantiene una
matrice {\(M_{t}\)} {\((m \times N^{\prime})\)} le cui entrate
{\(M_{t}\lbrack v,i\rbrack\)} indicano il numero di piani in {\(S_{t}\)}
in cui il veicolo {\(v\)} sarà il prossimo a partire dal cliente
{\(i\)}. Più formalmente possiamo dire:

\[M_{t}\lbrack v,i\rbrack = |\{\sigma \in S_{t}\ |\ \texttt{succ(}\sigma,\texttt{ldc(v))\ =\ i}\}|\]

in cui {\(\texttt{ldc(v)}\)} è l'ultimo cliente da cui il veicolo
{\(v\)} è partito nell'esecuzione del piano. La funzione consenso può
quindi essere definita come:

\[f_{t}(\sigma) = \sum\limits_{v = 1}^{m}M_{t}\lbrack v,\texttt{succ(}\sigma,\texttt{ldc(v))}\rbrack\]

\hypertarget{multiple-scenario-approach}{%
\section{Multiple Scenario Approach}\label{multiple-scenario-approach}}

{\(\mathbf{MSA}\)} riesce a superare di gran lunga il {\(\mathbf{MPA}\)}
utilizzando l'informazione stocastica sulle nuove richieste non ancora
sfruttata. L'idea chiave consiste nel generare nuovi piani di
instradamento per scenari che includono sia le richieste esistenti sia
possibili richieste future campionate dalla loro distribuzione di
probabilità. Una volta che un piano {\(\sigma\)} viene ottenuto,
{\(\mathbf{MSA}\)} \textbf{proietta} il piano sulle richieste note,
rimuovendo i futuri clienti ipotizzati e tale piano viene indicato con
{\(\sigma^{-}\)}. Il \textbf{piano proiettato} lascia quindi dei buchi
per gestire al meglio richieste future se si materializzano. Le gestione
degli eventi di {\(\mathbf{MSA}\)} sono le stesse di {\(\mathbf{MPA}\)},
si differenzia solamente nella generazione dei piani che cerca di
prevedere il futuro e solo i piani proiettati sono inseriti nell'insieme
dei piani {\(S_{t}\)}.

\hypertarget{conclusioni}{%
\section{Conclusioni}\label{conclusioni}}

Risultati sperimentali mostrano che quest'approccio per problemi di
routing dinamici e stocastici con un grado di dinamismo tra il
{\(30\%\)} e {\(80\%\)} produce estremi miglioramenti rispetto
all'approccio che non usa informazione stocastica. Si è anche notato una
forte sinergia tra {\(\mathbf{MSA}\)} e l'uso della funzione consenso,
specialmente per problemi con alto grado di dinamismo. Il paper mostra
anche che mantenere diversi piani di routing è fondamentale per ottenere
soluzioni di alta qualità in problemi di routing dinamico. Un possibile
miglioramento e sviluppo può risultare dall'analisi degli scenari in cui
le richieste future dinamiche eccedono la capacità di un veicolo e non
possono essere gestite. In tal caso sarebbe interessante tentare di
sviluppare strategie per rifiutare i clienti se è probabile che una tale
decisione migliori la qualità complessiva del piano.

\end{document}